function [run_result] = OHT_run_ampdistribK(params,domain,bdrys,experiment,run_type)

%OHT_run_ampdistribK: Function takes ln(K) and ln(Ss)
%values in a column vector and calculates either simulated amplitude
%observations, simulated amplitude fields (representing amplitude of phasor
%at all points within the model), or the reduced / simplified sensitivity
%matrix - sensitivity of amplitude observations to ln(K).
%
% Syntax:
%[run_result] = OHT_run_ampdistribK(params,domain, bdrys, experiment,run_type)
%
%where:
% OUTPUTS:
%   -run_result is the result of the model run, consisting of either a set
%   of simulated observations, a full picture of the forward model phasor
%   field (representing real and imaginary components of the phasor  at all
%   points within the model), or a sensitivity matrix for the given
%   observations. The output type depends on the "run_type" input.
%       -Run_type 1: run_result is a vector, representing all of the real
%       coefficients of the phasor (for each observation) followed by the
%       imaginary coefficients of the phasor. If the number of observations
%       is numobs, then the output is a (2*numobs x 1) vector.
%       -Run_type 2: run_result is a vector, representing the real part of
%       the phasor values at all points in space, followed by the imaginary
%       parts of the phasor at all points in space. If there are numcells
%       cells in the numerical model, the output is a (2*numcells x 1)
%       vector.
%       -Run_type 3: run_result is a matrix, representing the sensitivity
%       of all amplitude observations to ln(K) values in all grid cells.
%       Rows consist of all amplitude measurements.  Columns consist of
%       sensitivity to ln(K) in all model cells. Matrix size is thus
%       (numobs x numcells)
% INPUTS:
%       -params is the set of all ln(K) and ln(Ss) values for the model, as
%       a vector with 2*numcells ln(K) and ln(Ss) values, ordered in the
%       standard format according to meshgrid and reshape conventions.
%       -domain is a structure containing fields x,y, and z that describe
%       the boundaries of domain grid cells
%       -bdrys is a structure containing fields types and vals, that
%       describe the type and values at the 6 boundaries.
%       -experiment is a structure containing all information about
%       testing, as generated by OHT_create_inputs.m. See documentation of
%       that function for further information.
%
% Code by Michael Cardiff, 2015-2021

%Error checking, extract all needed information from structures
if ~isfield(domain,'x')
    error('X boundary information must be supplied in domain_disc.x');
else
    xb = domain.x;
end

if ~isfield(domain,'y')
    error('Y boundary information must be supplied in domain_disc.y');
else
    yb = domain.y;
end

if isfield(domain,'z')
    zb = domain.z;
else
    zb = [0 1];
end

bdry_types = bdrys.types;
bdry_vals = bdrys.vals;

num_omegas = size(experiment,1);
num_x = numel(xb)-1;
num_y = numel(yb)-1;
num_z = numel(zb)-1;
num_cells = num_x*num_y*num_z;

lnK = params(1:num_cells);
lnSs = params((num_cells+1):(2*num_cells));
lnK_mat = reshape(lnK,num_y,num_x,num_z);
lnSs_mat = reshape(lnSs,num_y,num_x,num_z);

num_obs = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_obs(i) = size(experiment(i).tests,1);
end
num_totalobs = sum(num_obs);
cum_totalobs = [0; cumsum(num_obs)];

num_stims = zeros(num_omegas,1);
for i = 1:1:num_omegas
    num_stims(i) = size(experiment(i).stims,2);
end
num_totalstims = sum(num_stims);
cum_totalstims = [0; cumsum(num_stims)];

sim_amps = zeros(num_totalobs,1);
amp_field = zeros(num_cells,num_totalstims);
H = zeros(num_totalobs,num_cells);

for i = 1:1:num_omegas
    firstobs = cum_totalobs(i) + 1;
    lastobs = cum_totalobs(i+1);
    firststim = cum_totalstims(i) + 1;
    laststim = cum_totalstims(i+1);
    switch run_type
        case 1
            [sim_obsPhi_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types);
            sim_amps(firstobs:lastobs) = abs(sim_obsPhi_omega);
            run_result = sim_amps;
        case 2
            [~,Phi_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types);
            amp_field(1:num_cells,firststim:laststim) = abs(Phi_omega);
            run_result = amp_field;
        case 3
            [~,Phi_omega,H_omega] = phasor_model_obssens...
                (experiment(i).omega,experiment(i).tests,experiment(i).obs,experiment(i).stims,bdry_vals,exp(lnK_mat),exp(lnSs_mat),...
                xb,yb,zb,bdry_types);
            %Convert sensitivity from wrt K and Ss to wrt ln(K) and ln(Ss)
            for j = 1:1:num_obs(i)
                H_omega{1}(j,:) = H_omega{1}(j,:).*exp(lnK)';
                H_omega{2}(j,:) = H_omega{2}(j,:).*exp(lnSs)';
            end
            %Using derivative of amplitude (\Phi_real^2 + \Phi_imag^2)^0.5
            H(firstobs:lastobs,:) = repmat([real(Phi_omega)./abs(Phi_omega)]',num_obs(i),1).*real([H_omega{1}]) ...
                +repmat([imag(Phi_omega)./abs(Phi_omega)]',num_obs(i),1).*imag([H_omega{1}]);
            run_result = H;            
        otherwise
            error('Only run type of 1, 2, or 3 is supported');
    end
end
